AWSTemplateFormatVersion: "2010-09-09"

Description: VPC Lattice Automation - Service Association

Parameters:
  StageNames:
    Type: String
    Description: List of stage names, separated by commas. For example, beta,gamma,prod

Resources:
# ---------- EVENTBRIDGE RULE -----------
  EventBridgeRule:
    Type: AWS::Events::Rule
    Properties:
      Name: "vpclattice-service-tags"
      Description: "Capture Changes VPC Lattice Service Tags."
      EventPattern:
        source:
          - aws.tag
        detail-type: 
          - "Tag Change on Resource"
        detail:
          changed-tag-keys:
            - equals-ignore-case: stage
          service:
            - vpc-lattice
          resource-type:
            - service
      Targets:
        - Arn: !GetAtt ServiceAssociationFunction.Arn
          Id: "LambdaFunction"
  
  # Lambda permission (for the EventBridge rule)
  EventBridgeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ServiceAssociationFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt EventBridgeRule.Arn

# ---------- LAMBDA FUNCTION ----------
  # IAM Role
  LambdaFuntionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: AllowLatticeActions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - vpc-lattice:ListServiceNetworks
                  - vpc-lattice:ListServiceNetworkServiceAssociations
                  - vpc-lattice:CreateServiceNetworkServiceAssociation
                  - vpc-lattice:DeleteServiceNetworkServiceAssociation
                Resource:
                  - "*"
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # CloudWatch Log Group
  LambdaFunctionLogGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: Encryption not required for this log group
    Type: AWS::Logs::LogGroup
    Properties: 
      LogGroupName: !Sub /aws/lambda/${ServiceAssociationFunction}
      RetentionInDays: 7

  # Function
  ServiceAssociationFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: CWL permissions granted by use of AWSLambdaBasicExecutionRole
          - id: W89
            reason: No requirement for this function to be in a VPC
          - id: W92
            reason: No requirement to limit simultaneous executions
    Type: AWS::Lambda::Function
    Properties:
      Description: Manage route table entry for CoreNetwork
      Runtime: python3.10
      Timeout: 30
      Role: !GetAtt LambdaFuntionRole.Arn
      Handler: index.lambda_handler
      Environment:
        Variables:
          STAGE_NAMES: !Ref StageNames
      Code:
        ZipFile: |-
          from functools import lru_cache

          import json
          import boto3
          import logging
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          stage_names_env = os.getenv('STAGE_NAMES') or ''
          stage_names = [k.strip().lower() for k in stage_names_env.split(',')]

          vpc_lattice = boto3.client('vpc-lattice')


          @lru_cache(maxsize=None)
          def list_all_service_networks():
              response = vpc_lattice.list_service_networks()
              service_networks = response['items'][:]
              while 'nextToken' in response:
                  response = vpc_lattice.list_service_networks(
                      nextToken=response['nextToken']
                  )
                  service_networks += response['items']
              return service_networks


          def get_service_network_for_stage(stage):
              """
              In the off-chance that multiple service networks with the same name are
              shared to this account, the first one found will be returned. This is
              because one service network can be associated to one VPC.
              """
              service_networks = list_all_service_networks()
              return next((sn for sn in service_networks if sn['name'] == stage.lower()), None)


          def get_new_stage(event):
              tags = event['detail']['tags']
              for k, v in tags.items():
                  if k.lower() == 'stage':
                      return v.lower()


          def delete_service_network_service_associations(associations):
              for association in associations:
                  vpc_lattice.delete_service_network_service_association(
                      serviceNetworkServiceAssociationIdentifier=association['id']
                  )
                  logger.info(f'Deleted association {json.dumps(association, default=str)}')


          def handle_create_tags(event, context):
              service_arn = event['resources'][0]
              stage = get_new_stage(event)
              service_network = get_service_network_for_stage(stage)

              if service_network is None:
                  raise Exception(f'Could not find service network for stage {stage}.')

              associations = vpc_lattice.list_service_network_service_associations(
                  serviceIdentifier=service_arn
              )['items'][:]
              
              # Delete association to the previous stage's service network if there was one
              old_stage_associations = [
                  a for a in associations
                  if a['serviceNetworkName'] in stage_names and a['serviceNetworkName'] != stage
              ]
              delete_service_network_service_associations(old_stage_associations)

              if stage in [a['serviceNetworkName'] for a in associations]:
                  return {
                      'statusCode': 200,
                      'body': {
                          'message': 'Already associated.'
                      }
                  }

              association = vpc_lattice.create_service_network_service_association(
                  serviceIdentifier=service_arn,
                  serviceNetworkIdentifier=service_network['id']
              )
              logger.info(f'Created association {json.dumps(association, default=str)}')

              return {
                  'statusCode': 200,
                  'body': {
                      'message': json.dumps(f'Created new association: {json.dumps(association, default=str)}')
                  }
              }


          def handle_delete_tags(event, context):
              """
              Deletes a service's associations with all stage-specific service networks.
              """
              service_arn = event['resources'][0]
              associations = vpc_lattice.list_service_network_service_associations(
                  serviceIdentifier=service_arn
              )['items'][:]

              stage_associations = [a for a in associations if a['serviceNetworkName'] in stage_names]
              delete_service_network_service_associations(stage_associations)

              return {
                  'statusCode': 200,
                  'body': {
                      'message': json.dumps(f'Deleted associations {json.dumps(stage_associations, default=str)}')
                  }
              }


          def lambda_handler(event, context):
              logger.info(f'Event: {json.dumps(event)}')
              
              if 'stage' in event['detail']['tags']:
                  return handle_create_tags(event, context)
              else:
                  return handle_delete_tags(event, context)

              return {
                  'statusCode': 400,
                  'body': {
                      'message': json.dumps(f'Invalid event input.')
                  }
              }