AWSTemplateFormatVersion: "2010-09-09"

Description: VPC Lattice Automation - Service Network (Centralized model)

Parameters:
  StageNames:
    Type: String
    Description: List of stage names, separated by commas. For example, beta,gamma,prod

Resources:
# ---------- EVENTBRIDGE SCHEDULER: AssociateSharedServices ----------
  AssociateSharedServicesScheduler:
    Type: AWS::Scheduler::Schedule
    Properties:
      Name: "associate-shared-services"
      FlexibleTimeWindow:
        Mode: "OFF"
      ScheduleExpression: "rate(1 minute)"
      Target:
        Arn: !GetAtt AssociateSharedServicesFunction.Arn
        RoleArn: !GetAtt AssociateSharedServicesSchedulerRole.Arn

  AssociateSharedServicesSchedulerRole:
      Type: AWS::IAM::Role
      Properties:
        Description: "EventBridge Scheduler - IAM Role (Associated Shared Services)"
        RoleName: associate-scheduler-shared-services
        AssumeRolePolicyDocument:
          Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - scheduler.amazonaws.com
              Action:
                - sts:AssumeRole
        Policies:
          - PolicyName: associate-scheduler-shared-services
            PolicyDocument:
              Version: "2012-10-17"
              Statement:
                - Effect: Allow
                  Action: "lambda:InvokeFunction"
                  Resource: !GetAtt AssociateSharedServicesFunction.Arn

# ---------- LAMBDA FUNCTION: AssociatedSharedServices ----------
  # IAM Roles
  AssociateSharedServicesLambdaFuntionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: AllowLatticeActions-Associate
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ram:AcceptResourceShareInvitation
                  - ram:GetResourceShareInvitations
                  - ram:GetResourceShares
                  - ram:ListResources
                  - vpc-lattice:ListServiceNetworks
                  - vpc-lattice:CreateServiceNetworkServiceAssociation
                  - vpc-lattice:ListServiceNetworkServiceAssociations
                Resource:
                  - "*"
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # CloudWatch Log Group
  AssociateSharedServicesLambdaFunctionLogGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: Encryption not required for this log group
    Type: AWS::Logs::LogGroup
    Properties: 
      LogGroupName: !Sub /aws/lambda/${AssociateSharedServicesFunction}
      RetentionInDays: 7

  # Function
  AssociateSharedServicesFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: CWL permissions granted by use of AWSLambdaBasicExecutionRole
          - id: W89
            reason: No requirement for this function to be in a VPC
          - id: W92
            reason: No requirement to limit simultaneous executions
    Type: AWS::Lambda::Function
    Properties:
      Description: Associate shared VPC Lattice services to the service network.
      Runtime: python3.10
      Timeout: 30
      Role: !GetAtt AssociateSharedServicesLambdaFuntionRole.Arn
      Handler: index.lambda_handler
      Environment:
        Variables:
          STAGE_NAMES: !Ref StageNames
          
      Code:
        ZipFile: |-
          import boto3
          import logging
          import os
          import json
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          ram_client = boto3.client('ram')
          vpc_lattice_client = boto3.client('vpc-lattice')

          allowlist_str = os.getenv('ALLOWLISTED_SHARE_ACCOUNTS') or ''
          allowlist = [a.strip() for a in allowlist_str.split(',')]
          allowlist_enabled = 'ALL' not in allowlist

          stage_names_env = os.getenv('STAGE_NAMES') or ''
          stage_names = [k.strip().lower() for k in stage_names_env.split(',')]
          stage_to_network_dict = None


          def lambda_handler(event, context):
              """
              Performs 2 actions:
              1. Accepts resource share invitations that are named after one of the permitted
              stage names and are sent by an allowlisted account.
              2. For every accepted resource share that is named after one of the permitted
              stage names and is sent by an allowlisted account, associates that share's
              services to the appropriate service network.
              
              Note: if you manually delete a ServiceNetworkServiceAssociation without
              deleting the RAM share, this Lambda Function will recreate the association.
              """
              logger.info(f'Received event {event} and context {context}')
              set_stage_to_network_dict()
              invitations = get_all_pending_resource_share_invitations()
              logger.info(f'Found invitations {invitations}')
              for invitation in invitations:
                  accept_pending_resource_share_invitation(invitation)
              associate_services_from_accepted_resource_shares()
              return {
                  'statusCode': 200,
                  'body': json.dumps('Successfully processed all pending invitations.')
              }


          def set_stage_to_network_dict():
              global stage_to_network_dict
              all_service_networks = get_all_service_networks()
              staged_service_networks = [sn for sn in all_service_networks if sn['name'] in stage_names]
              stage_to_network_dict = {sn['name']: sn['arn'] for sn in staged_service_networks}
              logger.info(f'Set stage to network dict {stage_to_network_dict}')


          def get_all_service_networks():
              service_networks = []
              paginator = vpc_lattice_client.get_paginator('list_service_networks')
              for page in paginator.paginate():
                  service_networks.extend(page['items'])
              return service_networks


          def get_all_pending_resource_share_invitations():
              invitations = []
              paginator = ram_client.get_paginator('get_resource_share_invitations')
              for page in paginator.paginate():
                  invitations.extend(page['resourceShareInvitations'])
              return [inv for inv in invitations if inv['status'] == 'PENDING']


          def accept_pending_resource_share_invitation(invitation):
              share_name = invitation['resourceShareName']
              share_arn = invitation['resourceShareArn']
              share_sender_account = invitation['senderAccountId']
              logger.info(f"Processing Resource Share Invitation {share_arn}, named {share_name}, from {share_sender_account}")
              
              if allowlist_enabled and share_sender_account not in allowlist:
                  logger.info(f'Share Invitation sender is not in allowlist. Ignoring Share Invitation {share_arn}.')
                  return
              
              if share_name not in stage_names:
                  logger.info(f'Share Invitation name does not match expected pattern, expected one of {stage_names}. Ignoring Share Invitation {share_arn}.')
                  return
              
              logger.info(f'Accepting Resource Share Invitation {share_arn}.')
              accepted_share = ram_client.accept_resource_share_invitation(
                  resourceShareInvitationArn=invitation['resourceShareInvitationArn']
              )


          def associate_services_from_accepted_resource_shares():
              shares = []
              paginator = ram_client.get_paginator('get_resource_shares')
              for page in paginator.paginate(
                  resourceOwner='OTHER-ACCOUNTS',
                  resourceShareStatus='ACTIVE'
              ):
                  shares.extend(page['resourceShares'])
              logger.info(f'Found existing resource shares: {shares}')
              for share in shares:
                  associate_services_from_accepted_resource_share(share)


          def associate_services_from_accepted_resource_share(share):
              share_name = share['name']
              share_arn = share['resourceShareArn']
              share_sender_account = share['owningAccountId']
              logger.info(f"Processing Accepted Resource Share {share_arn}, named {share_name}, from {share_sender_account}")
              
              if allowlist_enabled and share_sender_account not in allowlist:
                  logger.info(f'Share sender is not in allowlist. Ignoring Share {share_arn}.')
                  return
              
              if share_name not in stage_names:
                  logger.info(f'Share name does not match expected pattern, expected one of {stage_names}. Ignoring Share {share_arn}.')
                  return
              
              services = get_shared_services(share)
              logger.info(f'Found services in resource share {services}')    
              
              service_network_arn = stage_to_network_dict[share_name]
              for service in services:
                  create_association_if_not_associated(service_network_arn, service['arn'], share_name)


          def get_shared_services(resource_share):
              attempts = 0
              services = []
              while (len(services) == 0 and attempts < 5):
                  attempts += 1
                  services = ram_client.list_resources(
                      resourceShareArns=[resource_share['resourceShareArn']],
                      resourceOwner='OTHER-ACCOUNTS',
                      resourceType='vpc-lattice:Service'
                  )['resources']
                  time.sleep(1)
              return services


          def create_association_if_not_associated(
              service_network_identifier,
              service_identifier,
              share_name
          ):
              existing_associations = vpc_lattice_client.list_service_network_service_associations(
                  serviceNetworkIdentifier=service_network_identifier,
                  serviceIdentifier=service_identifier
              )['items']
              if (len(existing_associations) == 0):
                  logger.info(f'Associating Service {service_identifier} to {share_name} Service Network {service_network_identifier}')
                  vpc_lattice_client.create_service_network_service_association(
                      serviceNetworkIdentifier=service_network_identifier,
                      serviceIdentifier=service_identifier
                  )

# ---------- EVENTBRIDGE SCHEDULER: DisassociateSharedServices ----------
  EventBridgeDisassociateSharedServicesScheduler:
    Type: AWS::Scheduler::Schedule
    Properties:
      Name: "disassociate-shared-services"
      Description: "Checking VPC Lattice services shared with the Service Network Account."
      FlexibleTimeWindow:
        Mode: "OFF"
      ScheduleExpression: "rate(1 minute)"
      Target:
        Arn: !GetAtt DisassociateSharedServicesFunction.Arn
        RoleArn: !GetAtt EventBridgeDisassociateSharedServicesSchedulerRole.Arn

  EventBridgeDisassociateSharedServicesSchedulerRole:
      Type: AWS::IAM::Role
      Properties:
        Description: "EventBridge Scheduler - IAM Role (Disassociated Shared Services)"
        RoleName: disassociate-shared-services
        AssumeRolePolicyDocument:
          Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - scheduler.amazonaws.com
              Action:
                - sts:AssumeRole
        Policies:
          - PolicyName: disassociate-shared-services
            PolicyDocument:
              Version: "2012-10-17"
              Statement:
                - Effect: Allow
                  Action: "lambda:InvokeFunction"
                  Resource: !GetAtt DisassociateSharedServicesFunction.Arn

# ---------- LAMBDA FUNCTION: DisassociatedSharedServices ----------
  # IAM Roles
  DisassociateSharedServicesLambdaFuntionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: AllowLatticeActions-Disassociate
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - vpc-lattice:ListServiceNetworkServiceAssociations
                  - vpc-lattice:DeleteServiceNetworkServiceAssociation
                  - ram:ListResources
                Resource:
                  - "*"
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # CloudWatch Log Group
  DisassociateSharedServicesLambdaFunctionLogGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: Encryption not required for this log group
    Type: AWS::Logs::LogGroup
    Properties: 
      LogGroupName: !Sub /aws/lambda/${DisassociateSharedServicesFunction}
      RetentionInDays: 7

  # Function
  DisassociateSharedServicesFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: CWL permissions granted by use of AWSLambdaBasicExecutionRole
          - id: W89
            reason: No requirement for this function to be in a VPC
          - id: W92
            reason: No requirement to limit simultaneous executions
    Type: AWS::Lambda::Function
    Properties:
      Description: Disassociate VPC Lattice services to the service network.
      Runtime: python3.10
      Timeout: 30
      Role: !GetAtt DisassociateSharedServicesLambdaFuntionRole.Arn
      Handler: index.lambda_handler
      Environment:
        Variables:
          STAGE_NAMES: !Ref StageNames
      Code:
        ZipFile: |-
          import boto3
          import logging
          import os
          import json
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          ram_client = boto3.client('ram')
          vpc_lattice_client = boto3.client('vpc-lattice')

          allowlist_str = os.getenv('ALLOWLISTED_SHARE_ACCOUNTS') or ''
          allowlist = [a.strip() for a in allowlist_str.split(',')]

          stage_names_env = os.getenv('STAGE_NAMES') or ''
          stage_names = [k.strip().lower() for k in stage_names_env.split(',')]
          stage_to_network_dict = {k: os.getenv(k) for k in stage_names}


          def lambda_handler(event, context):
              logger.info(f'Received event {event} and context {context}')
              invitations = get_pending_resource_share_invitations()
              logger.info(f'Found invitations {invitations}')
              for invitation in invitations:
                  process_pending_resource_share_invitation(invitation)
              return {
                  'statusCode': 200,
                  'body': json.dumps('Successfully processed all pending invitations.')
              }


          def get_pending_resource_share_invitations():
              invitations = []
              paginator = ram_client.get_paginator('get_resource_share_invitations')
              for page in paginator.paginate():
                  invitations.extend(page['resourceShareInvitations'])
              return [inv for inv in invitations if inv['status'] == 'PENDING']


          def process_pending_resource_share_invitation(invitation):
              share_name = invitation['resourceShareName']
              share_arn = invitation['resourceShareArn']
              share_sender_account = invitation['senderAccountId']
              logger.info(f"Processing Resource Share Invitation {share_arn}, named {share_name}, from {share_sender_account}")
              
              if share_sender_account not in allowlist:
                  logger.info('Share Invitation sender is not in allowlist. Ignoring Share Invitation.')
                  return
              
              if share_name not in stage_names:
                  logger.info(f'Share Invitation name does not match expected pattern, expected one of {stage_names}. Ignoring Share Invitation.')
                  return
              
              logger.info('Accepting Resource Share Invitation.')
              accepted_share = ram_client.accept_resource_share_invitation(
                  resourceShareInvitationArn=invitation['resourceShareInvitationArn']
              )
              
              attempts = 0
              services = []
              while (len(services) == 0 and attempts < 5):
                  attempts += 1
                  services = ram_client.list_resources(
                      resourceShareArns=[accepted_share['resourceShareInvitation']['resourceShareArn']],
                      resourceOwner='OTHER-ACCOUNTS',
                      resourceType='vpc-lattice:Service'
                  )['resources']
                  time.sleep(1)
              
              logger.info(f'Found services in resource share {services}')
              
              sn_key = share_name.split('-')[-1]
              service_network_arn = stage_to_network_dict[sn_key]
              
              for service in services:
                  logger.info(f'Associating Service {service["arn"]} to {sn_key} Service Network {service_network_arn}')
                  vpc_lattice_client.create_service_network_service_association(
                      serviceIdentifier=service['arn'],
                      serviceNetworkIdentifier=service_network_arn
                  )