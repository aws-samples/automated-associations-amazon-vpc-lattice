AWSTemplateFormatVersion: "2010-09-09"

Description: VPC Lattice Automation - VPC Association

Parameters:
  StageNames:
    Type: String
    Description: List of stage names, separated by commas. For example, beta,gamma,prod

Resources:
# ---------- EVENTBRIDGE RULE -----------
  EventBridgeRule:
    Type: AWS::Events::Rule
    Properties:
      Name: "vpc-tags"
      Description: "Capture Changes in VPC Tags."
      EventPattern: "{\"source\":[\"aws.ec2\"],\"detail-type\":[\"AWS API Call via CloudTrail\"],\"detail\":{\"eventSource\":[\"ec2.amazonaws.com\"],\"eventName\":[\"CreateTags\",\"DeleteTags\"],\"requestParameters\":{\"resourcesSet\":{\"items\":{\"resourceId\":[{\"prefix\":\"vpc-\"}]}},\"tagSet\":{\"items\":{\"key\":[{\"equals-ignore-case\":\"stage\"}]}}}}}"
      Targets:
        - Arn: !GetAtt VPCAssociationFunction.Arn
          Id: "LambdaFunction"
  
  # Lambda permission (for the EventBridge rule)
  EventBridgeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref VPCAssociationFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt EventBridgeRule.Arn

# ---------- LAMBDA FUNCTION ----------
  # IAM Role
  LambdaFuntionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: AllowLatticeActions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - vpc-lattice:ListServiceNetworks
                  - vpc-lattice:ListServiceNetworkVpcAssociations
                  - vpc-lattice:GetServiceNetworkVpcAssociation
                  - vpc-lattice:CreateServiceNetworkVpcAssociation
                  - vpc-lattice:DeleteServiceNetworkVpcAssociation
                  - ec2:DescribeVpcs
                Resource:
                  - "*"
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # CloudWatch Log Group
  LambdaFunctionLogGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: Encryption not required for this log group
    Type: AWS::Logs::LogGroup
    Properties: 
      LogGroupName: !Sub /aws/lambda/${VPCAssociationFunction}
      RetentionInDays: 7

  # Function
  VPCAssociationFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: CWL permissions granted by use of AWSLambdaBasicExecutionRole
          - id: W89
            reason: No requirement for this function to be in a VPC
          - id: W92
            reason: No requirement to limit simultaneous executions
    Type: AWS::Lambda::Function
    Properties:
      Description: Manage route table entry for CoreNetwork
      Runtime: python3.10
      Timeout: 90
      Role: !GetAtt LambdaFuntionRole.Arn
      Handler: index.lambda_handler
      Environment:
        Variables:
          STAGE_NAMES: !Ref StageNames
      Code:
        ZipFile: |-
          from pip._internal import main

          main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
          sys.path.insert(0,'/tmp/')

          import json
          import boto3
          import logging
          import os
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          stage_names_env = os.getenv('STAGE_NAMES') or ''
          stage_names = [k.strip().lower() for k in stage_names_env.split(',')]

          vpc_lattice = boto3.client('vpc-lattice')


          def list_all_service_networks():
              response = vpc_lattice.list_service_networks()
              service_networks = response['items'][:]
              while 'nextToken' in response:
                  response = vpc_lattice.list_service_networks(
                      nextToken=response['nextToken']
                  )
                  service_networks += response['items']
              return service_networks


          def get_service_network_for_stage(stage):
              """
              In the off-chance that multiple service networks with the same name are
              shared to this account, the first one found with the name matching the stage
              will be returned. This is because a VPC can have one service network
              associated to it.
              """
              service_networks = list_all_service_networks()
              return next((sn for sn in service_networks if sn['name'] == stage.lower()), None)

          def delete_service_network_vpc_associations(associations):
              for association in associations:
                  vpc_lattice.delete_service_network_vpc_association(
                      serviceNetworkVpcAssociationIdentifier=association['id']
                  )
                  logger.info(f'Deleted association {json.dumps(association, default=str)}')
              if len(associations) > 0:
                  timeout = time.time() + 60
                  while True:
                      if time.time() > timeout:
                          raise Exception(f'Timed out waiting for previous associations {json.dumps(associations, default=str)} to be deleted')
                      for association in associations:
                          try:
                              vpc_lattice.get_service_network_vpc_association(
                                  serviceNetworkVpcAssociationIdentifier=association['id']
                              )
                              time.sleep(1)
                          except vpc_lattice.exceptions.ResourceNotFoundException:
                              time.sleep(1)
                              return


          def get_new_stage(event):
              tag_changes = event['detail']['requestParameters']['tagSet']['items']
              for tag_change in tag_changes:
                  if tag_change['key'].lower() == 'stage':
                      return tag_change['value'].lower()


          def handle_create_tags(event, context):
              vpc_id = event['detail']['requestParameters']['resourcesSet']['items'][0]['resourceId']
              stage = get_new_stage(event)
              
              service_network = get_service_network_for_stage(stage)
              if service_network is None:
                  raise Exception(f'Could not find service network for stage {stage}.')
              
              associations = vpc_lattice.list_service_network_vpc_associations(
                  vpcIdentifier=vpc_id
              )['items'][:]
              
              for a in associations:
                  if stage in a['serviceNetworkName']:
                      return {
                          'statusCode': 409,
                          'body': {
                              'message': json.dumps(f'Association for stage already exists: {a}.', default=str)
                          }
                      }
              
              old_stage_associations = [
                  a for a in associations
                  if a['serviceNetworkName'] in stage_names and a['serviceNetworkName'] != stage
              ]
              if len(old_stage_associations) < len(associations):
                  raise Exception(f'Unrelated service network association exists on this VPC: {json.dumps(associations, default=str)}')
              
              # Delete association to the previous stage's service network if there was one
              delete_service_network_vpc_associations(old_stage_associations)

              association = vpc_lattice.create_service_network_vpc_association(
                  vpcIdentifier=vpc_id,
                  serviceNetworkIdentifier=service_network['id']
              )
              logger.info(f'Created association {json.dumps(association, default=str)}')

              return {
                  'statusCode': 200,
                  'body': {
                      'message': json.dumps(f'Created new association: {association}', default=str)
                  }
              }


          def handle_delete_tags(event, context):
              """
              Deletes a VPC's association with a stage-specific service network.
              """
              vpc_id = event['detail']['requestParameters']['resourcesSet']['items'][0]['resourceId']
              associations = vpc_lattice.list_service_network_vpc_associations(
                  vpcIdentifier=vpc_id
              )['items']
              
              stage_associations = [a for a in associations if a['serviceNetworkName'] in stage_names]
              delete_service_network_vpc_associations(stage_associations)
              
              return {
                  'statusCode': 200,
                  'body': {
                      'message': json.dumps(f'Deleted associations {associations}', default=str)
                  }
              }
              

          def lambda_handler(event, context):
              logger.info(f'Event: {json.dumps(event)}')
              
              event_type = event['detail']['eventName']
              if event_type == 'CreateTags':
                  return handle_create_tags(event, context)
              elif event_type == 'DeleteTags':
                  return handle_delete_tags(event, context)
              
              return {
                  'statusCode': 400,
                  'body': {
                      'message': json.dumps(f'Invalid event input.')
                  }
              }